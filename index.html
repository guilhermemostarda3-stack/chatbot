<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ChatBot Completo</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js"></script>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        background: linear-gradient(135deg, #6e8efb, #a777e3);
        color: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
      }
      body.dark-mode {
        background: linear-gradient(135deg, #1a1a1a, #333);
        color: #fff;
      }
      #chat-wrapper {
        width: 1200px;
        height: 800px;
        margin: 20px auto;
        display: flex;
        border-radius: 20px;
        overflow: hidden;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        background: #fff;
        border: 5px solid #4caf50;
      }
      body.dark-mode #chat-wrapper {
        background: #2a2a2a;
        border: 5px solid #66bb6a;
      }
      #sidebar {
        width: 280px;
        background-color: #f0f2f5;
        padding: 20px;
        border-right: 1px solid #ddd;
        display: flex;
        flex-direction: column;
        gap: 10px;
        overflow-y: auto;
      }
      body.dark-mode #sidebar {
        background-color: #1a1a1a;
        border-right: 1px solid #444;
      }
      .sidebar-btn {
        padding: 12px;
        border-radius: 10px;
        text-align: left;
        cursor: pointer;
        background-color: #e2e4e7;
        color: #333;
        font-weight: 500;
        transition: background-color 0.2s, transform 0.2s;
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: relative;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      body.dark-mode .sidebar-btn {
        background-color: #333;
        color: #ddd;
      }
      .sidebar-btn:hover {
        background-color: #d1d4d8;
        transform: translateY(-2px);
      }
      body.dark-mode .sidebar-btn:hover {
        background-color: #444;
      }
      .sidebar-btn.active {
        background-color: #d1d4d8;
        border-left: 4px solid #4caf50;
        padding-left: 8px;
        font-weight: bold;
      }
      body.dark-mode .sidebar-btn.active {
        background-color: #444;
        border-left: 4px solid #66bb6a;
      }
      .sidebar-btn-options {
        font-weight: bold;
        font-size: 1.2em;
        cursor: pointer;
        padding: 0 5px;
      }
      .chat-menu {
        position: absolute;
        top: 100%;
        right: 0;
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 5px;
        flex-direction: column;
        z-index: 10;
        display: none;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        min-width: 120px;
      }
      body.dark-mode .chat-menu {
        background: #333;
        border: 1px solid #555;
      }
      .chat-menu button {
        background: none;
        border: none;
        padding: 10px;
        text-align: left;
        width: 100%;
        cursor: pointer;
        transition: background-color 0.2s;
        color: #000;
      }
      body.dark-mode .chat-menu button {
        color: #fff;
      }
      .chat-menu button:hover {
        background-color: #f0f0f0;
      }
      body.dark-mode .chat-menu button:hover {
        background-color: #444;
      }
      #main-chat-container {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        background-color: #fff;
      }
      body.dark-mode #main-chat-container {
        background-color: #2a2a2a;
      }
      #chat-header {
        padding: 20px;
        background-color: #f0f2f5;
        border-bottom: 1px solid #ddd;
        text-align: center;
        font-weight: bold;
        font-size: 1.2em;
      }
      body.dark-mode #chat-header {
        background-color: #1a1a1a;
        border-bottom: 1px solid #444;
      }
      #messages {
        flex-grow: 1;
        padding: 20px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      #input-container {
        display: flex;
        padding: 15px;
        border-top: 1px solid #ddd;
        background-color: #f0f2f5;
        align-items: center;
      }
      body.dark-mode #input-container {
        background-color: #1a1a1a;
        border-top: 1px solid #444;
      }
      #input-container input {
        flex-grow: 1;
        padding: 12px;
        border-radius: 20px;
        border: 1px solid #ccc;
        outline: none;
        font-size: 1em;
        background-color: #fff;
        color: #000;
      }
      body.dark-mode #input-container input {
        background-color: #333;
        border: 1px solid #555;
        color: #fff;
      }
      #input-container button {
        padding: 12px 20px;
        border: none;
        background-color: #4caf50;
        color: #fff;
        border-radius: 20px;
        margin-left: 10px;
        cursor: pointer;
        transition: background-color 0.2s;
        font-size: 1em;
      }
      #input-container button:hover {
        background-color: #45a049;
      }
      .message-wrapper {
        display: flex;
        flex-direction: column;
        position: relative;
      }
      .message {
        padding: 15px 20px;
        border-radius: 20px;
        max-width: 70%;
        line-height: 1.6;
        word-wrap: break-word;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
      }
      .message.user {
        background-color: #dcf8c6;
        align-self: flex-end;
        border-bottom-right-radius: 5px;
      }
      body.dark-mode .message.user {
        background-color: #005c4b;
      }
      .message.bot {
        background-color: #e5e5ea;
        align-self: flex-start;
        border-bottom-left-radius: 5px;
      }
      body.dark-mode .message.bot {
        background-color: #333;
      }
      .message.typing {
        font-style: italic;
        color: #666;
      }
      .message img {
        max-width: 100%;
        border-radius: 10px;
      }
      .message.pinned {
        border-left: 3px solid gold;
      }
      .file-sent-banner {
        font-size: 0.8em;
        color: #999;
        margin-bottom: 5px;
      }
      .msg-actions,
      .edit-actions {
        display: flex;
        gap: 5px;
        margin-top: 5px;
        opacity: 0;
        transition: opacity 0.2s;
      }
      .message-wrapper:hover .msg-actions,
      .edit-actions {
        opacity: 1;
      }
      .msg-actions button,
      .edit-actions button {
        background: #f0f0f0;
        border: 1px solid #ccc;
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 0.8em;
      }
      body.dark-mode .msg-actions button,
      body.dark-mode .edit-actions button {
        background: #444;
        border: 1px solid #666;
        color: #fff;
      }
      .edit-textarea {
        width: 100%;
        box-sizing: border-box;
        height: 100px;
        padding: 10px;
        border-radius: 10px;
        border: 1px solid #ccc;
      }
      .highlight-message {
        animation: highlight 2s ease-out forwards;
      }
      @keyframes highlight {
        0% {
          background-color: yellow;
        }
        100% {
          background-color: initial;
        }
      }
      .download-dropdown {
        position: relative;
        display: inline-block;
      }
      .download-dropdown-content {
        display: none;
        position: absolute;
        background-color: #f9f9f9;
        min-width: 100px;
        box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
        z-index: 1;
        flex-direction: column;
        border-radius: 5px;
        padding: 5px;
      }
      body.dark-mode .download-dropdown-content {
        background-color: #333;
      }
      .download-dropdown-content button {
        width: 100%;
        padding: 8px 10px;
        text-align: left;
      }
      #map-modal {
        display: none;
        position: fixed;
        z-index: 100;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        justify-content: center;
        align-items: center;
      }
      #map-modal-content {
        background-color: #fff;
        padding: 20px;
        border-radius: 10px;
        width: 80%;
        height: 80%;
        overflow: auto;
        position: relative;
      }
      body.dark-mode #map-modal-content {
        background-color: #2a2a2a;
      }
      #close-map-modal {
        position: absolute;
        top: 10px;
        right: 20px;
        font-size: 30px;
        font-weight: bold;
        cursor: pointer;
        color: #000;
      }
      body.dark-mode #close-map-modal {
        color: #fff;
      }
      .mermaid {
        height: 100%;
        width: 100%;
      }
      #user-profile-modal {
        display: none;
        position: fixed;
        z-index: 100;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        justify-content: center;
        align-items: center;
      }
      #user-profile-modal-content {
        background-color: #fff;
        padding: 30px;
        border-radius: 10px;
        max-width: 500px;
        width: 90%;
        position: relative;
        text-align: center;
      }
      body.dark-mode #user-profile-modal-content {
        background-color: #2a2a2a;
      }
      .profile-info p {
        margin: 10px 0;
      }
      #file-info-bar {
        display: none;
        justify-content: space-between;
        align-items: center;
        background-color: #e0f7fa;
        padding: 8px 15px;
        border-radius: 10px;
        margin-bottom: 10px;
        color: #00796b;
      }
      #file-info-bar span {
        font-weight: bold;
      }
      #file-info-bar button {
        background: none;
        border: none;
        color: #d32f2f;
        font-size: 1.2em;
        cursor: pointer;
      }
      #add-btn,
      #clear-chat-btn,
      #map-btn {
        background-color: #007bff;
        color: white;
        padding: 10px;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        font-size: 1.5em;
        border: none;
        margin-left: 10px;
      }
      #add-btn {
        position: relative;
      }
      #file-menu-dropdown {
        position: absolute;
        bottom: 100%;
        left: 0;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 5px;
        flex-direction: column;
        gap: 5px;
        padding: 5px;
        display: none;
      }
      #file-menu-dropdown button {
        background-color: transparent;
        color: #000;
      }
      #file-menu-dropdown button:hover {
        background-color: #f0f0f0;
      }
      body.dark-mode #file-menu-dropdown {
        background-color: #333;
        border: 1px solid #555;
      }
      body.dark-mode #file-menu-dropdown button {
        color: #fff;
      }
      #pinned-column {
        width: 300px;
        background-color: #f8f9fa;
        padding: 20px;
        border-left: 1px solid #ddd;
        display: none;
        flex-direction: column;
        gap: 15px;
        overflow-y: auto;
      }
      body.dark-mode #pinned-column {
        background-color: #1a1a1a;
        border-left: 1px solid #444;
      }
      #pinned-column h3 {
        margin: 0;
        font-size: 1.2em;
        text-align: center;
      }
      #pinned-column select {
        width: 100%;
        padding: 8px;
        border-radius: 5px;
        border: 1px solid #ccc;
        background-color: #fff;
      }
      body.dark-mode #pinned-column select {
        background-color: #333;
        color: #fff;
        border: 1px solid #555;
      }
      .pinned-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .pinned-btn {
        padding: 10px;
        border-radius: 8px;
        background-color: #e9ecef;
        border-left: 4px solid gold;
        cursor: pointer;
        transition: background-color 0.2s;
        font-size: 0.9em;
        line-height: 1.4;
      }
      body.dark-mode .pinned-btn {
        background-color: #444;
      }
      .pinned-btn:hover {
        background-color: #dee2e6;
      }
      body.dark-mode .pinned-btn:hover {
        background-color: #555;
      }
    </style>
  </head>
  <body>
    <div id="chat-wrapper">
      <div id="sidebar"></div>

      <div id="main-chat-container">
        <div id="chat-header">Novo Chat</div>
        <div id="messages"></div>
        <div id="file-info-bar">
          <span id="file-name-span"></span>
          <button onclick="clearFileSelection()">‚úñ</button>
        </div>
        <div id="input-container">
          <button id="add-btn">+</button>
          <input
            type="text"
            id="user-input"
            placeholder="Digite sua mensagem..."
          />
          <button id="send-btn">Enviar</button>
          <button id="clear-chat-btn" onclick="clearCurrentChat()">
            Limpar
          </button>
          <button id="map-btn">üåê</button>
        </div>
      </div>

      <div id="pinned-column">
        <h3>Mensagens Fixadas</h3>
        <select id="pinned-filter" onchange="filterPinned()">
          <option value="all">Todos</option>
          <option value="user">Usu√°rio</option>
          <option value="bot">IA</option>
        </select>
        <div id="pinned-list" class="pinned-list"></div>
      </div>
    </div>

    <div id="map-modal" class="modal">
      <div id="map-modal-content" class="modal-content">
        <span class="close" id="close-map-modal" onclick="closeModal('map-modal')"
          >&times;</span
        >
        <div id="mermaid-container"></div>
      </div>
    </div>

    <div id="user-profile-modal" class="modal">
      <div id="user-profile-modal-content" class="modal-content">
        <span
          class="close"
          id="close-user-profile-modal"
          onclick="closeModal('user-profile-modal')"
          >&times;</span
        >
        <h2>üë§ Seu Perfil</h2>
        <div class="profile-info">
          <p>
            Esta √© a tela de perfil do usu√°rio. Aqui voc√™ poderia exibir
            informa√ß√µes como nome, configura√ß√µes e hist√≥rico.
          </p>
          <p>
            *Esta √© uma funcionalidade em desenvolvimento e pode ser expandida
            futuramente.*
          </p>
        </div>
      </div>
    </div>

    <input
      type="file"
      id="upload-file"
      style="display: none"
      onchange="handleFileUpload(event)"
    />

    <script>
      const GIPHY_API_KEY = "eLIbdvWpV2XcSqhAIEYS5Bf7E47lLaRG";
      const localStorageKey = "chatbotChats";

      const sidebar = document.getElementById("sidebar");
      const messages = document.getElementById("messages");
      const userInput = document.getElementById("user-input");
      const mapBtn = document.getElementById("map-btn");
      const mapModal = document.getElementById("map-modal");
      const mermaidContainer = document.getElementById("mermaid-container");
      const userProfileModal = document.getElementById("user-profile-modal");
      const uploadFile = document.getElementById("upload-file");
      const fileInfoBar = document.getElementById("file-info-bar");
      const fileNameSpan = document.getElementById("file-name-span");
      const fileMenuDropdown = document.getElementById("file-menu-dropdown");
      const pinnedColumn = document.getElementById("pinned-column");
      const pinnedFilter = document.getElementById("pinned-filter");
      const pinnedList = document.getElementById("pinned-list");
      const clearChatBtn = document.getElementById("clear-chat-btn");
      const searchInput = document.getElementById("search-input");
      const modalContent = document.querySelector(".modal-content");

      let chats = [];
      let currentChat = -1;
      let uploadedFile = null;
      let isEditing = false;
      let originalMessageId = null;
      const activeRequests = new Map();

      document.addEventListener("DOMContentLoaded", () => {
        loadChats();
        if (chats.length > 0) {
          switchChat(0);
        } else {
          newChat();
        }
      });

      mapBtn.onclick = async () => {
        const botMessages = chats[currentChat].messages.filter(
          (m) => m.sender === "bot" && m.text && !m.isImage && !m.isLinkList
        );
        if (botMessages.length === 0) {
          alert("N√£o h√° mensagens de IA para mapear neste chat.");
          return;
        }
        const lastBotMessage = botMessages[botMessages.length - 1];

        const promptText = `Crie um mapa mental a partir do seguinte texto, no formato JSON. O JSON deve conter um array 'nodes' com os conceitos e um array 'links' com as conex√µes entre eles. As liga√ß√µes devem ser uma tupla [origem, destino]. Exemplo: {"nodes": ["conceito A", "conceito B"], "links": [["conceito A", "conceito B"]]}. Mapeie apenas a mensagem mais recente da IA: "${lastBotMessage.text}"`;

        const newId = Date.now();
        addMessageToChat(
          { text: "Gerando mapa mental...", sender: "bot" },
          currentChat
        );
        chats[currentChat].isTyping = true;
        renderCurrentChat();

        try {
          const response = await puter.ai.chat(promptText, {
            model: "gpt-5-nano",
          });
          const messageToUpdate = chats[currentChat].messages.find(
            (m) => m.id === newId
          );
          if (messageToUpdate) {
            messageToUpdate.text = response;
            showMapModal(response);
          }
        } catch (e) {
          console.error("Erro ao gerar mapa mental:", e);
          handleIncomingResponse(
            "N√£o foi poss√≠vel gerar o mapa. Por favor, tente novamente mais tarde.",
            newId,
            true
          );
        } finally {
          chats[currentChat].isTyping = false;
          renderCurrentChat();
          saveChats();
        }
      };

      function saveChats() {
        localStorage.setItem(localStorageKey, JSON.stringify(chats));
      }

      function loadChats() {
        const storedChats = localStorage.getItem(localStorageKey);
        if (storedChats) {
          chats = JSON.parse(storedChats);
        }
      }

      function newChat() {
        chats.push({ name: `Chat ${chats.length + 1}`, messages: [] });
        currentChat = chats.length - 1;
        renderSidebar();
        switchChat(currentChat);
        saveChats();
      }

      function switchChat(index) {
        if (isEditing) return;
        currentChat = index;
        renderSidebar();
        renderCurrentChat();
      }

      function renderCurrentChat() {
        messages.innerHTML = "";
        if (currentChat < 0) return;
        const currentMessages = chats[currentChat].messages;
        currentMessages.forEach((m) => {
          const messageElement = createMessageElement(m);
          messages.appendChild(messageElement);
        });
        if (chats[currentChat].isTyping) {
          messages.innerHTML += `<div class="message bot typing">Digitando...</div>`;
        }
        updateChatHeader();
        messages.scrollTop = messages.scrollHeight;
      }

      function updateChatHeader() {
        document.getElementById("chat-header").innerText =
          chats[currentChat].name;
      }

      function showUserProfile() {
        userProfileModal.style.display = "flex";
      }

      function clearAllChats() {
        if (confirm("Tem certeza de que deseja apagar TODOS os chats?")) {
          chats = [];
          newChat();
          saveChats();
          updatePinnedColumn();
        }
      }

      function renameChat(index) {
        const newName = prompt(
          "Digite o novo nome do chat:",
          chats[index].name
        );
        if (newName && newName.trim() !== "") {
          chats[index].name = newName.trim();
          renderSidebar();
          saveChats();
        }
      }

      function deleteChat(index) {
        if (
          confirm(
            `Tem certeza de que deseja apagar o chat "${chats[index].name}"?`
          )
        ) {
          chats.splice(index, 1);
          if (chats.length === 0) {
            newChat();
          } else {
            currentChat = Math.max(0, currentChat - 1);
            switchChat(currentChat);
          }
          saveChats();
          updatePinnedColumn();
        }
      }

      function renderSidebar() {
        sidebar.innerHTML = "";

        const userBtn = document.createElement("div");
        userBtn.className = "sidebar-btn";
        userBtn.innerHTML = `<span>üë§ Usu√°rio</span>`;
        userBtn.onclick = showUserProfile;
        sidebar.appendChild(userBtn);

        const pinnedBtn = document.createElement("div");
        pinnedBtn.className = "sidebar-btn";
        pinnedBtn.innerHTML = `<span>‚≠ê Fixados</span>`;
        pinnedBtn.onclick = togglePinnedColumn;
        sidebar.appendChild(pinnedBtn);

        chats.forEach((c, i) => {
          const btn = document.createElement("div");
          btn.className = "sidebar-btn" + (i === currentChat ? " active" : "");
          btn.innerHTML = `
            <span>${c.name}</span>
            <div class="sidebar-btn-options" onclick="event.stopPropagation(); showChatMenu(event, ${i})">...</div>
            <div id="chat-menu-${i}" class="chat-menu">
              <button onclick="renameChat(${i})">Renomear</button>
              <button onclick="deleteChat(${i})">Apagar</button>
            </div>
          `;
          btn.onclick = () => {
            switchChat(i);
            pinnedColumn.style.display = "none";
          };
          sidebar.appendChild(btn);
        });

        const newBtn = document.createElement("div");
        newBtn.className = "sidebar-btn";
        newBtn.textContent = "+ Novo Chat";
        newBtn.onclick = newChat;
        sidebar.appendChild(newBtn);

        const resetBtn = document.createElement("div");
        resetBtn.className = "sidebar-btn";
        resetBtn.textContent = "Apagar Tudo";
        resetBtn.style.backgroundColor = "#f44336";
        resetBtn.style.color = "#fff";
        resetBtn.onclick = clearAllChats;
        sidebar.appendChild(resetBtn);
      }

      function togglePinnedColumn() {
        const isVisible = pinnedColumn.style.display === "flex";
        pinnedColumn.style.display = isVisible ? "none" : "flex";
        if (!isVisible) {
          updatePinnedColumn();
        }
      }

      function showChatMenu(event, index) {
        document.querySelectorAll(".chat-menu").forEach((menu) => {
          menu.style.display = "none";
        });
        const menu = document.getElementById(`chat-menu-${index}`);
        menu.style.display = "flex";
      }

      document.addEventListener("click", function (event) {
        document.querySelectorAll(".chat-menu").forEach((menu) => {
          if (!menu.contains(event.target)) {
            menu.style.display = "none";
          }
        });
      });

      function downloadSingleMessage(text, type) {
        if (type === "pdf") {
          const { jsPDF } = window.jspdf;
          const doc = new jsPDF();
          doc.text(text, 10, 10);
          doc.save("mensagem.pdf");
        } else if (type === "word") {
          const blob = new Blob([text], {
            type: "application/msword",
          });
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = "mensagem.doc";
          link.click();
        }
      }

      async function downloadImage(imageUrl) {
        try {
          const response = await fetch(imageUrl);
          if (!response.ok) {
            throw new Error("Network response was not ok");
          }
          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.style.display = "none";
          a.href = url;
          a.download = `imagem_${Date.now()}.gif`;
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          document.body.removeChild(a);
        } catch (error) {
          console.error("Erro ao baixar a imagem:", error);
          alert(
            "N√£o foi poss√≠vel baixar a imagem. Por favor, tente novamente mais tarde."
          );
        }
      }

      function createMessageElement(messageData) {
        const {
          text,
          sender,
          pinned,
          fileName,
          id,
          chatIndex,
          isImage,
          isLinkList,
        } = messageData;

        const wrapper = document.createElement("div");
        wrapper.className = "message-wrapper";
        wrapper.setAttribute("data-id", id);

        if (fileName) {
          const fileBanner = document.createElement("div");
          fileBanner.className = "file-sent-banner";
          fileBanner.innerText = `Documento: ${fileName}`;
          wrapper.appendChild(fileBanner);
        }

        const msgDiv = document.createElement("div");
        msgDiv.className = "message " + sender;
        if (pinned) msgDiv.classList.add("pinned");

        if (isImage) {
          const imgElement = document.createElement("img");
          imgElement.src = text;
          imgElement.alt = "Imagem gerada por IA";
          msgDiv.appendChild(imgElement);
        } else if (isLinkList) {
          const title = document.createElement("p");
          title.innerHTML = `**Aqui est√£o alguns sites para encontrar imagens sobre o seu tema:**`;
          msgDiv.appendChild(title);
          const ul = document.createElement("ul");
          text.forEach((linkObj) => {
            const li = document.createElement("li");
            const a = document.createElement("a");
            a.href = linkObj.url;
            a.textContent = linkObj.name;
            a.target = "_blank";
            li.appendChild(a);
            ul.appendChild(li);
          });
          msgDiv.appendChild(ul);
        } else {
          msgDiv.innerText = text;
        }

        wrapper.appendChild(msgDiv);

        if (text) {
          const actions = document.createElement("div");
          actions.className = "msg-actions";
          actions.style.justifyContent =
            sender === "user" ? "flex-end" : "flex-start";

          if (sender === "bot") {
            const editBtn = document.createElement("button");
            editBtn.innerText = "Editar";
            editBtn.onclick = () => startEdit(id);
            actions.appendChild(editBtn);

            const summarizeBtn = document.createElement("button");
            summarizeBtn.innerText = "Resumir";
            summarizeBtn.onclick = async () => {
              const newId = Date.now();
              addMessageToChat({ text: "", sender: "bot" }, currentChat);
              chats[currentChat].isTyping = true;
              renderCurrentChat();
              try {
                const promptText = `Por favor, resuma o seguinte texto de forma concisa:\n\n"${text}"`;
                const response = await puter.ai.chat(promptText, {
                  model: "gpt-5-nano",
                });
                handleIncomingResponse(response, newId);
              } catch (e) {
                handleIncomingResponse(
                  "N√£o foi poss√≠vel gerar o resumo. Por favor, tente novamente mais tarde.",
                  newId,
                  true
                );
              }
            };
            actions.appendChild(summarizeBtn);

            const downloadDropdown = document.createElement("div");
            downloadDropdown.className = "download-dropdown";
            const downloadBtn = document.createElement("button");
            downloadBtn.innerText = "Download";
            downloadBtn.onclick = (e) => {
              e.stopPropagation();
              const dropdownContent = downloadBtn.nextElementSibling;
              dropdownContent.style.display =
                dropdownContent.style.display === "block" ? "none" : "block";
            };
            const dropdownContent = document.createElement("div");
            dropdownContent.className = "download-dropdown-content";

            if (isImage) {
              const imgDownloadBtn = document.createElement("button");
              imgDownloadBtn.innerText = "Baixar Foto";
              imgDownloadBtn.onclick = (e) => {
                e.stopPropagation();
                downloadImage(text);
                dropdownContent.style.display = "none";
              };
              dropdownContent.appendChild(imgDownloadBtn);
            } else {
              const pdfBtn = document.createElement("button");
              pdfBtn.innerText = "PDF";
              pdfBtn.onclick = (e) => {
                e.stopPropagation();
                downloadSingleMessage(text, "pdf");
                dropdownContent.style.display = "none";
              };
              const wordBtn = document.createElement("button");
              wordBtn.innerText = "Word";
              wordBtn.onclick = (e) => {
                e.stopPropagation();
                downloadSingleMessage(text, "word");
                dropdownContent.style.display = "none";
              };
              dropdownContent.appendChild(pdfBtn);
              dropdownContent.appendChild(wordBtn);
            }

            downloadDropdown.appendChild(downloadBtn);
            downloadDropdown.appendChild(dropdownContent);
            actions.appendChild(downloadDropdown);
          }

          const pinBtn = document.createElement("button");
          pinBtn.innerText = pinned ? "Desafixar" : "Fixar";
          pinBtn.onclick = () => {
            const m = chats[currentChat].messages.find((m) => m.id === id);
            if (m) {
              m.pinned = !m.pinned;
              saveChats();
              renderCurrentChat();
              updatePinnedColumn();
            }
          };
          const delBtn = document.createElement("button");
          delBtn.innerText = "Apagar";
          delBtn.onclick = () => {
            deleteMessage(id);
          };

          actions.appendChild(pinBtn);
          actions.appendChild(delBtn);

          wrapper.appendChild(actions);
        }

        return wrapper;
      }

      function addMessageToChat(messageData, chatIndex, aiRequestId = null) {
        const newMessage = {
          id: Date.now(),
          aiRequestId,
          ...messageData,
        };
        chats[chatIndex].messages.push(newMessage);
        saveChats();

        if (chatIndex === currentChat) {
          renderCurrentChat();
        }
        return newMessage;
      }

      function generateMermaidSyntaxFromJSON(jsonData) {
        if (!jsonData || !jsonData.nodes || !jsonData.links) {
          return null;
        }

        let mermaidSyntax = "graph TD\n";
        const nodeMap = new Map();
        jsonData.nodes.forEach((node, index) => {
          const safeNodeId = node.replace(/[^a-zA-Z0-9]/g, "_");
          nodeMap.set(node, `N${index}(["${node}"])`);
        });

        jsonData.links.forEach((link) => {
          const source = link[0];
          const target = link[1];
          if (nodeMap.has(source) && nodeMap.has(target)) {
            mermaidSyntax += `    ${nodeMap.get(source).split('(["')[0]} --> ${
              nodeMap.get(target).split('(["')[0]
            }\n`;
          }
        });

        let uniqueNodesSyntax = "";
        nodeMap.forEach((value) => {
          uniqueNodesSyntax += `    ${value}\n`;
        });

        return mermaidSyntax + uniqueNodesSyntax;
      }

      function showMapModal(aiResponse) {
        if (typeof aiResponse !== "string") {
          alert(
            "N√£o foi poss√≠vel gerar o mapa. A IA retornou um formato de dados inesperado. Por favor, tente mapear uma mensagem diferente."
          );
          return;
        }

        try {
          const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
          if (!jsonMatch) {
            throw new Error("Conte√∫do JSON n√£o encontrado na resposta.");
          }
          const jsonString = jsonMatch[0];

          const jsonData = JSON.parse(jsonString);
          const mermaidSyntax = generateMermaidSyntaxFromJSON(jsonData);

          if (!mermaidSyntax) {
            throw new Error("Formato JSON inv√°lido ou incompleto.");
          }

          mermaidContainer.innerHTML = `<pre class="mermaid">${mermaidSyntax}</pre>`;
          mapModal.style.display = "block";
          mermaid.init(undefined, mermaidContainer);
        } catch (e) {
          console.error("Erro ao gerar mapa:", e);
          const errorMessage = `N√£o foi poss√≠vel gerar o mapa. A IA retornou um formato de dados inesperado. Por favor, tente mapear uma mensagem diferente. Detalhes: ${e.message}`;
          alert(errorMessage);
        }
      }

      function closeModal(modalId) {
        document.getElementById(modalId).style.display = "none";
      }

      window.onclick = function (event) {
        if (event.target == mapModal) {
          closeModal("map-modal");
        }
        if (event.target == userProfileModal) {
          closeModal("user-profile-modal");
        }
      };

      function updatePinnedColumn() {
        const filterValue = pinnedFilter.value;
        pinnedList.innerHTML = "";

        const allPinned = [];
        chats.forEach((chat, chatIndex) => {
          chat.messages.forEach((msg) => {
            if (msg.pinned) {
              allPinned.push({
                ...msg,
                chatIndex: chatIndex,
                chatName: chat.name,
              });
            }
          });
        });

        const filteredPinned = allPinned.filter(
          (m) => filterValue === "all" || m.sender === filterValue
        );

        if (filteredPinned.length === 0) {
          pinnedList.innerHTML = `<p style="color:#666;text-align:center;padding:20px;">Nenhuma mensagem fixada.</p>`;
          return;
        }

        filteredPinned.forEach((m) => {
          const btn = document.createElement("div");
          btn.className = "pinned-btn";
          btn.innerHTML = `**${m.chatName} (${m.sender})**<br>${m.text.slice(
            0,
            50
          )}...`;
          btn.onclick = () => goToPinnedMessage(m.chatIndex, m.id);
          pinnedList.appendChild(btn);
        });
      }

      function filterPinned() {
        updatePinnedColumn();
      }

      function goToPinnedMessage(chatIndex, messageId) {
        switchChat(chatIndex);
        setTimeout(() => {
          const msgDiv = document.querySelector(
            `[data-id="${messageId}"] .message`
          );
          if (msgDiv) {
            msgDiv.scrollIntoView({ behavior: "smooth", block: "center" });
            msgDiv.classList.add("highlight-message");
            setTimeout(() => {
              msgDiv.classList.remove("highlight-message");
            }, 2000);
          }
        }, 100);
      }

      function toggleTheme() {
        document.body.classList.toggle("dark-mode");
        modalContent.classList.toggle("dark-mode");
      }

      function clearCurrentChat() {
        if (currentChat < 0) return;
        if (confirm("Deseja apagar todas as mensagens do chat?")) {
          messages.innerHTML = "";
          chats[currentChat].messages = [];
          saveChats();
          updatePinnedColumn();
        }
      }

      function searchMessages() {
        const term = searchInput.value.toLowerCase();
        document.querySelectorAll(".message").forEach((msg) => {
          msg.parentElement.style.display = msg.innerText
            .toLowerCase()
            .includes(term)
            ? "flex"
            : "none";
        });
      }

      function handleFileUpload(event) {
        const file = event.target.files[0];
        if (file) {
          uploadedFile = file;
          userInput.value = "Analisar documento";
          fileNameSpan.textContent = uploadedFile.name;
          fileInfoBar.style.display = "flex";
        }
        event.target.value = null;
        fileMenuDropdown.style.display = "none";
      }

      function clearFileSelection() {
        uploadedFile = null;
        userInput.value = "";
        fileNameSpan.textContent = "";
        fileInfoBar.style.display = "none";
      }

      function deleteMessage(messageId) {
        const messageIndex = chats[currentChat].messages.findIndex(
          (m) => m.id === messageId
        );
        if (messageIndex === -1) return;

        const messageToDelete = chats[currentChat].messages[messageIndex];

        if (messageToDelete.sender === "bot") {
          if (
            messageToDelete.aiRequestId &&
            activeRequests.has(messageToDelete.aiRequestId)
          ) {
            activeRequests.get(messageToDelete.aiRequestId).controller.abort();
            activeRequests.delete(messageToDelete.aiRequestId);
          }
          if (
            messageIndex > 0 &&
            chats[currentChat].messages[messageIndex - 1].sender === "user"
          ) {
            chats[currentChat].messages.splice(messageIndex - 1, 2);
          } else {
            chats[currentChat].messages.splice(messageIndex, 1);
          }
        } else {
          const botMessageIndex = messageIndex + 1;
          if (
            botMessageIndex < chats[currentChat].messages.length &&
            chats[currentChat].messages[botMessageIndex].sender === "bot"
          ) {
            const botMessage = chats[current - 1].messages[botMessageIndex];
            if (
              botMessage.aiRequestId &&
              activeRequests.has(botMessage.aiRequestId)
            ) {
              activeRequests.get(botMessage.aiRequestId).controller.abort();
              activeRequests.delete(botMessage.aiRequestId);
            }
            chats[currentChat].messages.splice(messageIndex, 2);
          } else {
            chats[currentChat].messages.splice(messageIndex, 1);
          }
        }

        renderCurrentChat();
        saveChats();
        updatePinnedColumn();
      }

      function isGifRequest(text) {
        const gifKeywords = [
          "gif",
          "giphy",
          "gify",
          "jif",
          "jiphy",
          "me mostra um gif",
          "me mostra um gife",
          "procurar gif",
          "encontrar gif",
          "criar gif",
          "fazer gif",
        ];
        const lowerCaseText = text.toLowerCase();
        return gifKeywords.some((keyword) => lowerCaseText.includes(keyword));
      }

      function isImageRequest(text) {
        const imageKeywords = [
          "foto",
          "imagem",
          "figura",
          "desenho",
          "ilustracao",
          "gerar foto",
          "criar imagem",
          "procurar foto",
          "mostrar foto",
          "me mostra uma imagem",
          "me mostra uma foto",
          "me mostra um desenho",
          "procura uma imagem",
          "procurar imagem",
          "buscar foto",
          "buscar imagem",
          "crie uma imagem de",
          "faz uma imagem de",
          "desenha um",
          "desenha uma",
          "fotografia de",
        ];
        const lowerCaseText = text.toLowerCase();
        return imageKeywords.some((keyword) => lowerCaseText.includes(keyword));
      }

      function extractSearchTerm(text) {
        const keywordsToRemove = [
          "foto",
          "imagem",
          "figura",
          "desenho",
          "gif",
          "giphy",
          "gify",
          "jif",
          "jiphy",
          "ilustracao",
          "arte",
          "pintura",
          "gravura",
          "esbo√ßo",
          "sketch",
          "renderizacao",
          "fotografia",
          "image",
          "picture",
          "de",
          "do",
          "da",
          "o",
          "a",
          "um",
          "uma",
          "me",
          "mostra",
          "quero",
          "ver",
          "procurar",
          "mostrar",
          "buscar",
          "criar",
          "gere",
          "crie",
          "mostre",
          "preciso",
          "procure",
          "visualizar",
          "exibir",
          "encontrar",
          "desenhe",
          "desenhar",
          "renderizar",
          "faz",
          "picture",
          "of",
        ];
        const lowerCaseText = text.toLowerCase();
        const words = lowerCaseText.split(" ");
        const filteredWords = words.filter(
          (word) => !keywordsToRemove.includes(word)
        );
        return filteredWords.join(" ").trim();
      }

      async function searchForGif(searchTerm, botMessageId) {
        try {
          const url = `https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_API_KEY}&q=${searchTerm}&limit=1&offset=0&rating=g&lang=en`;
          const response = await fetch(url);
          const data = await response.json();

          const messageToUpdate = chats[currentChat].messages.find(
            (m) => m.id === botMessageId
          );

          if (data.data && data.data.length > 0) {
            const imageUrl = data.data[0].images.original.url;
            messageToUpdate.text = imageUrl;
            messageToUpdate.isImage = true;
          } else {
            messageToUpdate.text = `Desculpe, n√£o encontrei nenhum gif para "${searchTerm}".`;
          }
        } catch (error) {
          console.error("Erro ao buscar o gif:", error);
          const messageToUpdate = chats[currentChat].messages.find(
            (m) => m.id === botMessageId
          );
          messageToUpdate.text =
            "Ocorreu um erro ao carregar o gif. Tente novamente mais tarde.";
        } finally {
          chats[currentChat].isTyping = false;
          renderCurrentChat();
          saveChats();
        }
      }

      function searchForImageLinks(searchTerm, botMessageId) {
        const links = [
          {
            name: "Pexels",
            url: `https://www.pexels.com/search/${searchTerm}/`,
          },
          {
            name: "Pixabay",
            url: `https://pixabay.com/images/search/${searchTerm}/`,
          },
          {
            name: "Unsplash",
            url: `https://unsplash.com/s/photos/${searchTerm}`,
          },
          {
            name: "Freepik",
            url: `https://www.freepik.com/search?format=search&query=${searchTerm}`,
          },
        ];

        const messageToUpdate = chats[currentChat].messages.find(
          (m) => m.id === botMessageId
        );
        messageToUpdate.text = links;
        messageToUpdate.isLinkList = true;
        chats[currentChat].isTyping = false;
        renderCurrentChat();
        saveChats();
      }

      async function sendMessage(
        text = userInput.value.trim(),
        file = uploadedFile
      ) {
        if (currentChat < 0) newChat();

        if (!text && !file) return;

        for (let [reqId, reqData] of activeRequests.entries()) {
          reqData.controller.abort();
          activeRequests.delete(reqId);
        }
        chats[currentChat].isTyping = false;

        const userMessage = addMessageToChat(
          { text, sender: "user", fileName: file ? file.name : null },
          currentChat
        );

        userInput.value = "";
        clearFileSelection();

        const searchTerm = extractSearchTerm(text);

        if (isGifRequest(text)) {
          const placeholderMessage = addMessageToChat(
            { text: "Buscando gif...", sender: "bot", isImage: false },
            currentChat
          );
          chats[currentChat].isTyping = true;
          renderCurrentChat();
          searchForGif(searchTerm, placeholderMessage.id);
          return;
        }

        if (isImageRequest(text)) {
          const placeholderMessage = addMessageToChat(
            {
              text: "Buscando links de imagens gratuitas...",
              sender: "bot",
              isLinkList: false,
            },
            currentChat
          );
          chats[currentChat].isTyping = true;
          renderCurrentChat();
          searchForImageLinks(searchTerm, placeholderMessage.id);
          return;
        }

        let prompt = text;

        if (file) {
          try {
            const fileReader = new FileReader();
            const fileContent = await new Promise((resolve, reject) => {
              fileReader.onload = (e) => resolve(e.target.result);
              fileReader.onerror = (e) => reject(e);
              fileReader.readAsText(file);
            });
            prompt = `O usu√°rio fez o upload de um arquivo. O conte√∫do do arquivo √©:\n\n---\n${fileContent}\n---\n\nE a pergunta √©: "${text}". Por favor, analise o documento e responda √† pergunta.`;
          } catch (e) {
            console.error("Failed to read file:", e);
            const errorMessage =
              "Desculpe, n√£o consegui ler o arquivo. Por favor, tente outro formato ou arquivo.";
            addMessageToChat(
              { text: errorMessage, sender: "bot" },
              currentChat
            );
            return;
          }
        }

        const controller = new AbortController();
        const signal = controller.signal;
        const aiRequestId = Date.now();

        const placeholderMessage = addMessageToChat(
          { text: "", sender: "bot", aiRequestId },
          currentChat
        );
        activeRequests.set(aiRequestId, { controller });

        chats[currentChat].isTyping = true;
        renderCurrentChat();

        try {
          const response = await puter.ai.chat(prompt, {
            model: "gpt-5-nano",
            signal,
          });
          handleIncomingResponse(response, aiRequestId);
        } catch (e) {
          if (e.name === "AbortError") {
            console.log("AI request aborted");
            handleIncomingResponse(null, aiRequestId, false, true);
          } else {
            console.error("AI request failed:", e);
            const errorMessage =
              "Desculpe, o servi√ßo de IA falhou. Por favor, tente novamente.";
            handleIncomingResponse(errorMessage, aiRequestId, true);
          }
        }
      }

      async function handleIncomingResponse(
        text,
        requestId,
        isError = false,
        isAborted = false
      ) {
        const requestData = activeRequests.get(requestId);
        if (isAborted) {
          return;
        }

        activeRequests.delete(requestId);

        let messageToUpdate = chats[currentChat].messages.find(
          (m) => m.aiRequestId === requestId
        );

        if (messageToUpdate) {
          if (isAborted) {
            const userMessageIndex = chats[currentChat].messages.findIndex(
              (m) => m.id === messageToUpdate.id - 1
            );
            if (userMessageIndex !== -1) {
              chats[currentChat].messages.splice(userMessageIndex, 2);
            }
          } else {
            messageToUpdate.text = text;
          }
        }

        chats[currentChat].isTyping = false;
        renderCurrentChat();
        saveChats();
      }

      function startEdit(id) {
        if (isEditing) return;

        isEditing = true;
        originalMessageId = id;

        const messageElement = document.querySelector(
          `.message-wrapper[data-id="${id}"] .message`
        );
        const originalText = messageElement.innerText;

        const textarea = document.createElement("textarea");
        textarea.className = "edit-textarea";
        textarea.value = originalText;

        messageElement.replaceWith(textarea);

        const actionsContainer = document.querySelector(
          `.message-wrapper[data-id="${id}"] .msg-actions`
        );
        actionsContainer.style.display = "none";

        const editActions = document.createElement("div");
        editActions.className = "edit-actions";

        const saveBtn = document.createElement("button");
        saveBtn.innerText = "Salvar";
        saveBtn.className = "save";
        saveBtn.onclick = () => saveEdit(id, textarea.value);

        const cancelBtn = document.createElement("button");
        cancelBtn.innerText = "Cancelar";
        cancelBtn.className = "cancel";
        cancelBtn.onclick = () => cancelEdit(id, originalText);

        editActions.appendChild(saveBtn);
        editActions.appendChild(cancelBtn);

        textarea.after(editActions);

        textarea.focus();
      }

      function saveEdit(id, newText) {
        const messageObject = chats[currentChat].messages.find(
          (m) => m.id === id
        );
        if (messageObject) {
          messageObject.text = newText;
        }

        isEditing = false;
        renderCurrentChat();
        saveChats();
      }

      function cancelEdit(id, originalText) {
        const messageElement = document.querySelector(
          `.message-wrapper[data-id="${id}"] textarea`
        );
        const originalDiv = document.createElement("div");
        originalDiv.className = "message bot";
        originalDiv.innerText = originalText;

        messageElement.replaceWith(originalDiv);

        const editActions = document.querySelector(
          `.message-wrapper[data-id="${id}"] .edit-actions`
        );
        editActions.remove();

        const actionsContainer = document.querySelector(
          `.message-wrapper[data-id="${id}"] .msg-actions`
        );
        actionsContainer.style.display = "flex";

        isEditing = false;
        renderCurrentChat();
      }

      userInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          sendMessage();
        }
      });
      document
        .getElementById("send-btn")
        .addEventListener("click", () => sendMessage());
      document.getElementById("add-btn").addEventListener("click", () => {
        const dropdown = document.getElementById("file-menu-dropdown");
        dropdown.style.display =
          dropdown.style.display === "flex" ? "none" : "flex";
      });
      document.getElementById("btn-pdf").onclick = () => uploadFile.click();
      document.getElementById("btn-word").onclick = () => uploadFile.click();
      document.getElementById("btn-txt").onclick = () => uploadFile.click();

      const themeToggleBtn = document.createElement("button");
      themeToggleBtn.innerText = "üåô";
      themeToggleBtn.style.cssText =
        "position: fixed; bottom: 20px; right: 20px; font-size: 24px; background: #fff; border-radius: 50%; width: 50px; height: 50px; border: 2px solid #ccc; cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.1);";
      themeToggleBtn.onclick = toggleTheme;
      document.body.appendChild(themeToggleBtn);
    </script>
  </body>
</html>
